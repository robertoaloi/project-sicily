# project-sicily
Change Sicily, change the way politics work.

> What would happen if a Software Engineer had to write a political
> programme?  It would probably start with an empty repository and a
> README file.

So, here we are.

## The Project

Politics are complex activities. They involve endless discussions and
debate between parties. They aim at solving problems and improving
lives. They are not perfect. In fact, even if they often start with
some good intent, sometimes they are poorely implemented and they need
to be iterated upon.

If we think in these terms, politics are not very different from
**software**. Software also aims at solving complex problems and it is
not perfect. Imperfections in software are commonly known as _bugs_.

There is a huge difference between politics and software, though. In
the past 50 years we dramatically changed the way we produce software.
We did not do the same for politics.

It always surprises me how in politics people still trust individuals
or groups who pretend to have **the solution** to their problems, like
if they were some mythological _dei ex machina_.  Complex problems
require thinking, experimentation and compromises. The more this
thinking is made public and transparent, the more chances to succeed
it has. In software, the price of finding a bug in the design phase
of a product is much, much smaller than finding it after the product
is live and used by millions of users. The same applies to politics.

Politicians tend to be vague and to blame each other. This does not
(well, most of the time) happen in the software world because
engineers can always point to a _superior_ source of truth behind
their software: the _source code_. The concept of _source code_ does
not exist for politics, at least in their current form.

But what if we could apply the lessons learnt in 50 years of writing
software to politics and start using the same technology and tools?
We could have an **open source** political programme, accessible by
everyone, where it is easy to contribute with new ideas, either by
reporting _issues_ or by submitting a _pull request_. It would be
possible to track the evolution of the programme in a non-ambiguous
way and it would be easy to blame or give credit the correct
contributor. It would be a great way to share knowledge, formalize
problems, learn from the past. In case of contrasting opinions, a
_fork_ of the programme would still be an option.

Surely there would be a steep learning curve for contributors who are
not familiar with the IT world, but would it be a bad thing to expose
them to concepts such as __version control__, __pull requests__ and
__forks__? Would it be too hard of a challenge?

There is only way to discover how things would go. I have to write a
**Manifesto for Sicily**.
